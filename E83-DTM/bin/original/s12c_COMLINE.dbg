	include	"s12c_128.sfr"
	include	"s12c_COMLINE.sfr"
	title	"s12c_COMLINE  Copyright (C) 2005-2011, micro dynamics GmbH"
;------------------------------------------------------------------------------
;Module:	s12c_COMLINE.asm
;
;Copyright:	(C) 2005-2011, micro dynamics GmbH
;Author(s):	Michael Frank
;Update:	20.01.2011
;
;Description:	Funktionen der Programmier-Schnittstelle
;
;Folgende Bezeichner sind in s12p_COMLINE.sfr zu definieren:
;
;Switches:	fBlockRead
;		fCalibration
;		fE_CMD_CALLBACK
;		fV_CMD_CALLBACK
;
;------------------------------------------------------------------------------
;Revision History:	Original Version  01.05
;
;20.01.2011	neue Schalter: fBlockRead, fCalibration, fE_CMD_CALLBACK und fV_CMD_CALLBACK
;		Korrektur in GET_DATA_HANDLE: Echo erst am Schluss der Funktion, da
;               anderenfalls der Zeitablauf bei s12c_SoftUart nicht sichergestellt
;28.08.2009	in V_CMD Aufruf von Callbackfunktion V_CMD_EXECUTE neu hinzugefügt
;
;29.07.2009	function COMLINE_TIMEOUTS neu
;28.07.2009	neue Kommandos: SelectSector und ReadSector
;               Kommandos ReadFirstSector und ReadNextSector restlos wieder entfernt
;29.06.2009	neue Kommandos: ReadFirstSector und ReadNextSector
;24.06.2009	zusätzlichen Speicherbereich DATA_FLASH berücksichtigen
;12.06.2009	8-bit Prüfsumme durch CRC-16/X25 Prüfcode ersetzt
;
;24.11.2006	Einbindung der externen SoftUart-Funktionen SCI_???
;20.11.2006	Parameterspeicher im FLASH-Speicher
;08.11.2006	Anpassung an MC9S12C128
;
;03.04.2006	in COMLINE_RESET Sendeleitung stets deaktivieren
;		in O_CMD Wartezeit verlängert
;		Zeitgrenzen jetzt in Abhängigkeit von BUS_CLK setzen
;------------------------------------------------------------------------------
					;
;------------------------------------------------------------------------------
;Externals
;------------------------------------------------------------------------------
					;
;					;
;Anwendungsprogramm			;
;
;begin 20.01.2011
 if fE_CMD_CALLBACK
 endif
 if fBlockRead
 endif
 if fV_CMD_CALLBACK
 endif
;end
;
;					;
;s12c_CRC.asm				;
	xref	CREATE_KERMIT		;Code
	xref	CREATE_X25		;Code
;					;
;s12c_FTS.asm				;
	xref	FTS_COPY		;Code
	xref	FTS_FLASH		;Code
	xref	FTS_WRITE8		;Code
	xref	FTS_WRITE16		;Code
;					;
;s12c_Uart.asm				;
	xref	SCI_READ8		;Code
	xref	SCI_RESET		;Code
	xref	SCI_TX_DISABLE		;Code
	xref	SCI_TX_ENABLE		;Code
	xref	SCI_WRITE8		;Code
;
;begin 20.01.2011
 if fBlockRead == _true
 endif
;end
;
					;
	xref	CONFIG_TBL		;roData
 					;
;
;begin 20.01.2011
 if fCalibration == _true
 endif
;end
;
					;
	xref	E_CONFIG_CRC		;bssData
	xref	E_CONFIG_TBL		;bssData
					;
	xref	B_EEPROM		;Data
	xref	T_EEPROM		;Data
;
;begin 20.01.2011
 if fCalibration
 endif
;end
;
	xref	B_RAM			;Data
	xref	T_RAM			;Data
					;
;
;begin 20.01.2011
 if fBlockRead == _true
 endif
;end
;
					;
	xref	BUS_CLK			;Number
;
;begin 20.01.2011
 if fCalibration == _true
 endif
;end
;
	xref.b	CONFIG_TBL_CNT		;Number
	xref.b	C_STEP			;Number
	xref	SCI_SECTOR_SIZE		;Number
	xref	RX_TIMEOUT_CT		;Number
	xref	TX_TIMEOUT_CT		;Number
					;
;------------------------------------------------------------------------------
;Publics
;------------------------------------------------------------------------------
					;
	xdef	COMLINE_INPUT		;Code
	xdef	COMLINE_REACTION	;Code
	xdef	COMLINE_RESET		;Code
	xdef	COMLINE_TIMEOUTS	;Code
					;
;------------------------------------------------------------------------------
;Variablen und Konstanten
;------------------------------------------------------------------------------
					;
.locals:	section
					;
BOV:
					;
CML_FLAGS:	ds.b	1		;Flags
_TX_FLAG:	equ	bit0		;1, wenn Echo erwartet wird
_RX_FLAG:	equ	bit1		;1, wenn Datenempfang erwartet wird
_COMLINE_ERROR:	equ	bit2		;temporärer Kommunikationsfehler
_CMD_MODE_FLAG:	equ	bit3		;1, wenn Kommando aktiv
_GET_DATA_FLAG:	equ	bit4		;1, wenn Datenempfang aktiv
_PUT_DATA_FLAG:	equ	bit5		;1, wenn Datenausgabe aktiv
_COMLINE_FLAG:	equ	bit6		;1, wenn RS232-Kommunikation aktiv
_COMLINE_TRIG:	equ	bit7		;Startflag für die RS232-Kommunikation aktiv
					;
CMD_FLAGS:	ds.b	1		;Flags
;
;
;
;
;
;
;
_BLOCKREAD:	equ	bit7		;1, solange Sektor-Blocktransfer läuft
					;
TX_BUFFER:	ds.b	1		;DATA8: Ausgabebuffer
RX_BUFFER:	ds.b	1		;DATA8: Empfangsbuffer
					;
		even
TX_TIMEOUT:	ds.w	1		;DATA16: Zeitzähler für Sende-Echo
RX_TIMEOUT:	ds.w	1		;DATA16: Zeitzähler für Datenempfang
IO_PTR:		ds.w	1		;DATA16: Zeiger für RS232 Kommandos
IO_CTR:		ds.w	1		;DATA16: Bytezähler für RS232 Kommandos
					;
IO_DATA_PTR:	ds.w	1		;DATA16: Zeiger für RS232 Kommandos
IO_DATA_CTR:	ds.w	1		;DATA16: Bytezähler für RS232 Kommandos
					;
PARAMETER_BLOCK:
PB_TYPE:	ds.b	1		;DATA8: Speichertyp der Datenquelle
					;	0 : interner RAM-, EEPROM- oder FLASH-Speicher
					;	1 : externer FRAM-Datenspeicher
					;	sonst : nicht definiert
PB_PAGE:	ds.w	1		;DATA16: undefiniert (Type = 0) oder PAGE-Adresse (TYPE = 1)
PB_OFFSET:	ds.w	1		;DATA16: Adresse (TYPE = 0) oder OFFSET-Adresse (TYPE = 1)
PARAMETER_CNT:		equ	* - PARAMETER_BLOCK
					;
TOV:
					;
.text:		section
					;
;-----------------------------------------------------------------------------
;Public: COMLINE_RESET bringt die RS232-Schnittstelle in Grundstellung.
;
;Eingangsparameter:	keine
;Ausgangsparameter:	keine
;veränderte Register:	CCR, A, X, Y
;-----------------------------------------------------------------------------
					;
COMLINE_RESET:
	LDY	#BOV			;
	LDX	#(TOV - BOV)		;
	LDAA	#0			;
COMLINE_RESET1:
	STAA	1,Y+			;alle Variablen auf null setzen
	DBNE	X,COMLINE_RESET1	;
					;
	JSR	SCI_RESET		;
	RTS				;
					;
;-----------------------------------------------------------------------------
;Public: COMLINE_TIMEOUT prüft den RS232-Sende und RS232-Empfangskanal auf
;Wartezeitüberschreitung.
;
;Eingangsparameter:	RX_TIMEOUT
;			TX_TIMEOUT
;Ausgangsparameter:	RX_TIMEOUT
;			TX_TIMEOUT
;			CML_FLAGS._TX_FLAG
;			CML_FLAGS._COMLINE_ERROR
;veränderte Register:	CCR, A, B
;-----------------------------------------------------------------------------
					;
COMLINE_TIMEOUTS:
	BRCLR	CML_FLAGS,_CMD_MODE_FLAG,COMLINE_TIMEOUTS8
					;
	LDD	RX_TIMEOUT		;wenn CML_FLAGS._CMD_MODE_FLAG
	BEQ	COMLINE_TIMEOUTS1	;dann
	SUBD	#1			;
	STD	RX_TIMEOUT		;  wenn RX_TIMEOUT_abgelaufen,
	BNE	COMLINE_TIMEOUTS1	;  dann
	BSET	CML_FLAGS,_COMLINE_ERROR;    _COMLINE_ERROR setzen
					;
COMLINE_TIMEOUTS1:
	LDD	TX_TIMEOUT		;
	BEQ	COMLINE_TIMEOUTS2	;
	SUBD	#1			;
	STD	TX_TIMEOUT		;  wenn TX_TIMEOUT_abgelaufen,
	BNE	COMLINE_TIMEOUTS2	;  dann
	BSET	CML_FLAGS,_COMLINE_ERROR;    _COMLINE_ERROR setzen
	BCLR	CML_FLAGS,_TX_FLAG	;    und _TX_FLAG ruecksetzen
					;
COMLINE_TIMEOUTS2:
	BRA	COMLINE_TIMEOUTS9	;
					;
COMLINE_TIMEOUTS8:
	LDD	#0FFFFh			;sonst
	STD	RX_TIMEOUT		;  RX_TIMEOUT auf Höchstwert
	LDD	#0FFFFh			;
	STD	TX_TIMEOUT		;  TX_TIMEOUT auf Höchstwert
					;
COMLINE_TIMEOUTS9:
	RTS				;
					;
;-----------------------------------------------------------------------------
;Public: COMLINE_INPUT nimmt Zeichen vom RS232-Empfangskanal entgegen.
;Es wird zwischen einem Echo eines vorher gesendeten Zeichens und einem
;echt empfangenen Zeichen unterschieden.
;
;Eingangsparameter:	CML_FLAGS._TX_FLAG
;Ausgangsparameter:	CML_FLAGS._TX_FLAG
;			CML_FLAGS._RX_FLAG
;			CML_FLAGS._COMLINE_ERROR
;veränderte Register:	CCR, A
;-----------------------------------------------------------------------------
					;
COMLINE_INPUT:
;
;begin 20.01.2011
 if fBlockRead == _true
 endif
;end
;
	JSR	SCI_READ8		;wenn neues Zeichen da,
	BCS	COMLINE_INPUT3		;dann
	STAA	RX_BUFFER		;  empfangenes Zeichen lesen
	BRSET	CML_FLAGS,_TX_FLAG,COMLINE_INPUT1
	BSET	CML_FLAGS,_RX_FLAG	;wenn Echoflag rückgesetzt,
	JMP	COMLINE_INPUT3		;dann RX_FLAG setzen
COMLINE_INPUT1:
	LDAA	TX_BUFFER		;
	CMPA	RX_BUFFER		;wenn empfangenes <> gesendetem Zeichen,
	BEQ	COMLINE_INPUT2		;dann
	BSET	CML_FLAGS,_COMLINE_ERROR;  Fehler bei der Datenübertragung
COMLINE_INPUT2:
	BCLR	CML_FLAGS,_TX_FLAG	;Echoflag rücksetzen
					;
COMLINE_INPUT3:
	RTS				;
					;
;-----------------------------------------------------------------------------
;Public: COMLINE_REACTION wertet empfangene Kommandocodes aus und
;bearbeitet die entsprechenden Aufgaben.
;
;Eingangsparameter:	CML_FLAGS._CMD_MODE_FLAG
;			CML_FLAGS._RX_FLAG
;Ausgangsparameter:	CML_FLAGS._RX_FLAG
;veränderte Register:	CCR, A
;-----------------------------------------------------------------------------
					;
COMLINE_REACTION:
;
;begin 20.01.2011
 if fBlockRead == _true
 endif
;end
;
	BRSET	CML_FLAGS,_CMD_MODE_FLAG,COMLINE_REACTION1
	BRSET	CML_FLAGS,_RX_FLAG,COMLINE_REACTION2
	JMP	COMLINE_REACTION3	;
					;
COMLINE_REACTION1:
	JSR	CMD_EXECUTE		;
	JMP	COMLINE_REACTION3	;Kommando bearbeiten
					;
COMLINE_REACTION2:
	JSR	CMD_DECODE		;Kommandocode entschlüsseln
					;
COMLINE_REACTION3:
	RTS				;
					;
;-----------------------------------------------------------------------------
;CMD_DECODE
;
;Eingangsparameter:
;Ausgangsparameter:
;veränderte Register:	CCR, A, B, X
;-----------------------------------------------------------------------------
					;
CMD_DECODE:
	LDAB	RX_BUFFER		;alle Kommandos mit Ausnahme von OPEN
	CMPB	#'O'			;werden nur bei gesetztem _COMLINE_FLAG
	BEQ	CMD_DECODE0		;ausgeführt
	BRCLR	CML_FLAGS,_COMLINE_FLAG,NO_CMD
					;
CMD_DECODE0:
	SUBB	#41h			;
	CMPB	#1Ah			;
	BHS	CMD_DECODE3		;
	CLRA				;
	LSLD				;
	LDX	#CMD_TBL		;
	JMP	[D,X]			;
					;
CMD_DECODE1:
	STAA	TX_BUFFER		;
	JSR	SCI_WRITE8		;
;
;begin 20.01.2011
 if fBlockRead == _true
 endif
;end
;
					;
CMD_DECODE2:
	BSET	CML_FLAGS,_CMD_MODE_FLAG;
					;
CMD_DECODE3:
	BCLR	CML_FLAGS,_RX_FLAG	;
	RTS				;
					;
CMD_TBL:
;
;begin 20.01.2011
 if fBlockRead == _true
 else
	dc.w	NO_CMD			;A
	dc.w	NO_CMD			;B
 endif
;end
;
	dc.w	C_CMD			;C	Close
	dc.w	D_CMD			;D	Default
	dc.w	E_CMD			;E	Execute
	dc.w	NO_CMD			;F
	dc.w	NO_CMD			;G
	dc.w	NO_CMD			;H
	dc.w	NO_CMD			;I
	dc.w	NO_CMD			;J
	dc.w	NO_CMD			;K
	dc.w	NO_CMD			;L
	dc.w	NO_CMD			;M
	dc.w	NO_CMD			;N
	dc.w	O_CMD			;O	Open
	dc.w	P_CMD			;P	SetPointer
	dc.w	NO_CMD			;Q
	dc.w	R_CMD			;R	Read
	dc.w	S_CMD			;S	SetSize
	dc.w	NO_CMD			;T
	dc.w	NO_CMD			;U
	dc.w	V_CMD			;V	SetConfigCRC
	dc.w	W_CMD			;W	Write
;
;begin 20.01.2011
 if fCalibration == _true
 else
	dc.w	NO_CMD			;X
 endif
;end
;
	dc.w	NO_CMD			;Y
	dc.w	NO_CMD			;Z
					;
NO_CMD:
	JMP	CMD_DECODE3		;
					;
;
;begin 20.01.2011
 if fBlockRead == _true
 endif
;end
;
					;
;-----------------------------------------------------------------------------
;C_CMD	schaltet die TxD-Leitung auf General Purpose IO um.
;-----------------------------------------------------------------------------
					;
C_CMD:
	JSR	SCI_TX_DISABLE		;TxD-Leitung abschalten
	BCLR	CML_FLAGS,_COMLINE_FLAG	;COMLINE_FLAG rücksetzen
	JMP	CMD_DECODE3		;
					;
;-----------------------------------------------------------------------------
;D_CMD	setzt alle programmierbaren Einstellungen auf Defaultwerte.
;-----------------------------------------------------------------------------
					;
D_CMD:
	MOVW	#CONFIG_TBL,R4		;Quelladresse
	MOVW	#E_CONFIG_TBL,R6	;Zieladresse
	MOVB	#CONFIG_TBL_CNT,R3	;Anzahl Bytes
	JSR	FTS_COPY		;Konfiguration schreiben
	JSR	FTS_FLASH		;
					;
	LDX	#E_CONFIG_TBL		;Prüfcode der programmierbaren Werte
	MOVW	#CONFIG_TBL_CNT,R2	;
	JSR	CREATE_KERMIT		;neu berechnen
	MOVW	#E_CONFIG_CRC,R6	;
	JSR	FTS_WRITE16		;und schreiben
	JSR	FTS_FLASH		;EEPROM neu programmieren
					;
	LDAA	#0-'D'			;
	JMP	CMD_DECODE1		;
					;
;-----------------------------------------------------------------------------
;E_CMD	startet nach dem Empfang von Kommandocode und Parametern die
;Ausführung eines Kommandos.
;-----------------------------------------------------------------------------
					;
E_CMD:
;
;begin 20.01.2011
 if fE_CMD_CALLBACK = _true
 endif
;end
;
					;
	LDAA	#0-'E'			;
	JMP	CMD_DECODE1		;
					;
;-----------------------------------------------------------------------------
;O_CMD	schaltet die TxD-Leitung auf die RS232-Kommunikation um.
;
;Nur dieses Kommando setzt das COMLINE_FLAG.
;Alle sonstigen Kommandos werden bei nicht gesetztem COMLINE_FLAG
;vollständig ignoriert.
;-----------------------------------------------------------------------------
					;
O_CMD_STR:
	dc.b	0FFh, 0-'O'
O_CMD_CNT:	equ	(* - O_CMD_STR)
					;
O_CMD:
	JSR	SCI_TX_ENABLE		;TxD-Leitung zuschalten
	BSET	CML_FLAGS,_COMLINE_TRIG	;_COMLINE_TRIG setzen
	LDX	#BUS_CLK		;ca. 10 ms abwarten
O_CMD1:
	NOP				;	1
	NOP				;	1
	NOP				;	1
	NOP				;	1
	NOP				;	1
	NOP				;	1
	DEX				;	1
	BNE	O_CMD1			;	3
					;
	MOVW	#O_CMD_STR,IO_PTR	;Zeiger auf Antwortstring
	MOVW	#O_CMD_CNT-1,IO_CTR	;Anzahl Bytes - 1
	BSET	CML_FLAGS,_PUT_DATA_FLAG;Daten senden
	JMP	CMD_DECODE2		;
					;
;-----------------------------------------------------------------------------
;P_CMD	empfängt die Startadresse für ein folgendes Schreib-/Lesekommando.
;-----------------------------------------------------------------------------
					;
P_CMD:
	MOVW	#IO_DATA_PTR,IO_PTR	;Zeiger auf Datenadresse
	MOVW	#1,IO_CTR		;Anzahl Bytes - 1
	BSET	CML_FLAGS,_GET_DATA_FLAG;Daten empfangen
					;
	LDAA	#0-'P'			;
	JMP	CMD_DECODE1		;
					;
;-----------------------------------------------------------------------------
;R_CMD	sendet Daten an den PC.
;-----------------------------------------------------------------------------
					;
R_CMD:
	MOVW	IO_DATA_PTR,IO_PTR	;Zeiger auf Datenquelle
	MOVW	IO_DATA_CTR,IO_CTR	;Anzahl Bytes - 1
	BSET	CML_FLAGS,_PUT_DATA_FLAG;Daten senden
					;
	LDAA	#0-'R'			;
	JMP	CMD_DECODE1		;
					;
;-----------------------------------------------------------------------------
;S_CMD	empfängt die Byteanzahl für ein folgendes Schreib-/Lesekommando.
;-----------------------------------------------------------------------------
					;
S_CMD:
	MOVW	#IO_DATA_CTR,IO_PTR	;Zeiger auf Datenanzahl
	MOVW	#1,IO_CTR		;Anzahl Bytes - 1
	BSET	CML_FLAGS,_GET_DATA_FLAG;Daten empfangen
					;
	LDAA	#0-'S'			;
	JMP	CMD_DECODE1		;
					;
;-----------------------------------------------------------------------------
;V_CMD	aktualisiert den Prüfcode der programmierbaren Einstellungen.
;-----------------------------------------------------------------------------
					;
V_CMD:
;
;begin 20.01.2011
 if fV_CMD_CALLBACK == _true
 endif
;end
;
	LDX	#E_CONFIG_TBL		;Prüfcode der programmierbaren Werte
	MOVW	#CONFIG_TBL_CNT,R2	;
	JSR	CREATE_KERMIT		;neu berechnen
	MOVW	#E_CONFIG_CRC,R6	;
	JSR	FTS_WRITE16		;und schreiben
	JSR	FTS_FLASH		;EEPROM neu programmieren
					;
	LDAA	#0-'V'			;
	JMP	CMD_DECODE1		;
					;
;-----------------------------------------------------------------------------
;W_CMD	empfängt Daten vom PC und schreibt sie.
;-----------------------------------------------------------------------------
					;
W_CMD:
	MOVW	IO_DATA_PTR,IO_PTR	;Zeiger auf Datenziel
	MOVW	IO_DATA_CTR,IO_CTR	;Anzahl Bytes - 1
	BSET	CML_FLAGS,_GET_DATA_FLAG;Daten senden
					;
	LDAA	#0-'W'			;
	JMP	CMD_DECODE1		;
					;
;
;begin 20.01.2011
 if fCalibration == _true
 endif
;end
;
					;
;-----------------------------------------------------------------------------
;CMD_EXECUTE prüft, welche Aktion innerhalb eines RS232-Kommandos als
;nächstes ausgeführt werden muss und verzweigt entsprechend.
;
;Eingangsparameter:	CML_FLAGS,_TX_FLAG
;			CML_FLAGS,_RX_FLAG
;			CML_FLAGS,_COMLINE_ERROR
;			IO_PTR
;			IO_CTR
;Ausgangsparameter:     CML_FLAGS,_TX_FLAG
;			CML_FLAGS,_RX_FLAG
;			CML_FLAGS,_COMLINE_ERROR
;			IO_PTR
;			IO_CTR
;veränderte Register:	CCR, A, B, X, Y, R[0..3,8,10]
;-----------------------------------------------------------------------------
					;
CMD_EXECUTE:
	BRSET	CML_FLAGS,_PUT_DATA_FLAG,CMD_EXECUTE1
	BRSET	CML_FLAGS,_GET_DATA_FLAG,CMD_EXECUTE2
	JMP	CMD_EXECUTE3		;
					;
CMD_EXECUTE1:
	JSR	PUT_DATA_HANDLE		;Daten senden
	JMP	CMD_EXECUTE3		;
					;
CMD_EXECUTE2:
	JSR	GET_DATA_HANDLE		;Daten empfangen
					;
					;
CMD_EXECUTE3:
	JSR	CHK_CMD_STATUS		;prüfen, ob Kommando fertig bearbeitet
	RTS				;
					;
;-----------------------------------------------------------------------------
;PUT_DATA_HANDLE gibt ein Zeichen an der RS232-Schnittstelle aus.
;
;Eingangsparameter:	CML_FLAGS,_TX_FLAG
;			CML_FLAGS,_COMLINE_ERROR
;			CML_FLAGS,_COMLINE_TRIG
;			IO_PTR
;			IO_CTR
;			TX_TIMEOUT
;Ausgangsparameter:     CML_FLAGS,_COMLINE_TRIG
;			CML_FLAGS,_COMLINE_FLAG
;			CML_FLAGS,_PUT_DATA_FLAG
;			IO_PTR
;			IO_CTR
;			TX_TIMEOUT
;veränderte Register:	CCR, A, B, X
;-----------------------------------------------------------------------------
					;
PUT_DATA_HANDLE:
	BRCLR	CML_FLAGS,_TX_FLAG,PUT_DATA_HANDLE1
	JMP	PUT_DATA_HANDLE9	;wenn _TX_FLAG rückgesetzt
PUT_DATA_HANDLE1:
	BRCLR	CML_FLAGS,_COMLINE_ERROR,PUT_DATA_HANDLE2
	JMP	PUT_DATA_HANDLE9	;und _COMLINE_ERROR rückgesetzt
					;dann
PUT_DATA_HANDLE2:
	LDX	IO_PTR			;
	LDAA	0,X			;  Zeichen aus internem Speicher lesen
	INX				;  Zeiger incrementieren
	STX	IO_PTR			;
	STAA	TX_BUFFER		;  Zeichen merken
	JSR	SCI_WRITE8		;  und ausgeben
	BSET	CML_FLAGS,_TX_FLAG	;  Ausgabeflag setzen
	LDD	#TX_TIMEOUT_CT		;
	STD	TX_TIMEOUT		;  Echo-Timeout auf Startwert
	LDD	IO_CTR			;
	SUBD	#1			;  Anzahl decrementieren
	STD	IO_CTR			;  wenn alle Zeichen übertragen,
	BCC	PUT_DATA_HANDLE9	;  dann
	BCLR	CML_FLAGS,_PUT_DATA_FLAG;    Übertragung beenden
	BRCLR	CML_FLAGS,_COMLINE_TRIG,PUT_DATA_HANDLE9
	BSET	CML_FLAGS,_COMLINE_FLAG	;    wenn _COMLINE_TRIG gesetzt,
	BCLR	CML_FLAGS,_COMLINE_TRIG	;    dann _COMLINE_FLAG setzen
					;
PUT_DATA_HANDLE9:
	RTS				;
					;
;-----------------------------------------------------------------------------
;GET_DATA_HANDLE empfängt ein Zeichen von der RS232-Schnittstelle und
;schreibt es ins EEPROM, DATA-FLASH oder RAM.
;
;Eingangsparameter:	CML_FLAGS,_RX_FLAG
;			CML_FLAGS,_COMLINE_ERROR
;			IO_PTR
;			IO_CTR
;			RX_TIMEOUT
;Ausgangsparameter:     CML_FLAGS,_RX_FLAG
;			CML_FLAGS,_GET_DATA_FLAG
;			IO_PTR
;			IO_CTR
;			RX_TIMEOUT
;veränderte Register:	CCR, A, B, Y, R[0,6..7]
;-----------------------------------------------------------------------------
					;
GET_DATA_HANDLE:
	BRSET	CML_FLAGS,_RX_FLAG,GET_DATA_HANDLE1
	JMP	GET_DATA_HANDLE9	;wenn _RX_FLAG gesetzt
GET_DATA_HANDLE1:
	BRCLR	CML_FLAGS,_COMLINE_ERROR,GET_DATA_HANDLE2
	JMP	GET_DATA_HANDLE9	;und _COMLINE_ERROR rückgesetzt
					;dann
GET_DATA_HANDLE2:
	LDY	IO_PTR			;
	CPY	#B_EEPROM		;
	BLO	GET_DATA_HANDLE2a	;
	CPY	#T_EEPROM		;
	BHI	GET_DATA_HANDLE2a	;
	STY	R6			;  wenn Zieladresse im EEPROM-Bereich,
	MOVB	RX_BUFFER,R0		;  dann
	JSR	FTS_WRITE8		;    Zeichen ins EEPROM programmieren
	LDAA	RX_BUFFER		;
	JMP	GET_DATA_HANDLE2d	;
					;
GET_DATA_HANDLE2a:
	LDY	IO_PTR			;
	CPY	#B_RAM			;
	BLO	GET_DATA_HANDLE2b	;
	CPY	#T_RAM			;
	BHI	GET_DATA_HANDLE2b	;  sonst wenn Zieladresse im RAM-Bereich,
	LDAA	RX_BUFFER		;  dann
	STAA	0,Y			;    Zeichen im RAM ablegen
	JMP	GET_DATA_HANDLE2d	;
					;
GET_DATA_HANDLE2b:
;
;begin 20.01.2011
 if fCalibration
 endif
;end
;
					;
GET_DATA_HANDLE2c:
	LDAA	RX_BUFFER		;  sonst Schreiben nicht möglich!
	COMA				;  Echo invertieren
;
;begin 20.01.2011
	STAA	RX_BUFFER		;  und zwischenspeichern
;end
;
					;
GET_DATA_HANDLE2d:
;
;begin 20.01.2011
;end
;
	LDY	IO_PTR			;
	INY				;  Zeiger incrementieren
	STY	IO_PTR			;
	LDD	#RX_TIMEOUT_CT		;
	STD	RX_TIMEOUT		;  Empfangs-Timeout auf Startwert
	BCLR	CML_FLAGS,_RX_FLAG	;  _RX_FLAG rücksetzen
	LDD	IO_CTR			;
	SUBD	#1			;  Anzahl decrementieren
	STD	IO_CTR			;  wenn alle Zeichen empfangen,
;
;begin 20.01.2011
	BCC	GET_DATA_HANDLE8	;  dann
	JSR	FTS_FLASH		;    ggf. EEPROM neu programmieren
	BCLR	CML_FLAGS,_GET_DATA_FLAG;    Datenempfang beenden
					;
GET_DATA_HANDLE8:
	LDAA	RX_BUFFER		;
	JSR	SCI_WRITE8		;  Echo senden
;end
;
					;
GET_DATA_HANDLE9:
	RTS				;
					;
;-----------------------------------------------------------------------------
;CHK_CMD_STATUS untersucht den ordnungsgemässen Abschluss eines Kommandos
;und deaktiviert dann das _CMD_MODE_FLAG.
;
;Eingangsparameter:	CML_FLAGS._PUT_DATA_FLAG
;			CML_FLAGS._GET_DATA_FLAG
;			CML_FLAGS._COMLINE_ERROR
;Ausgangsparameter:     CML_FLAGS._CMD_MODE_FLAG
;			CML_FLAGS._PUT_DATA_FLAG
;			CML_FLAGS._GET_DATA_FLAG
;			CML_FLAGS._COMLINE_ERROR
;veränderte Register:	CCR, A, X, Y
;-----------------------------------------------------------------------------
					;
CHK_CMD_STATUS:
	BRSET	CML_FLAGS,_PUT_DATA_FLAG,CHK_CMD_STATUS1
	BRSET	CML_FLAGS,_GET_DATA_FLAG,CHK_CMD_STATUS1
	BCLR	CML_FLAGS,_CMD_MODE_FLAG;
					;
CHK_CMD_STATUS1:
	BRCLR	CML_FLAGS,_COMLINE_ERROR,CHK_CMD_STATUS9
	LDAA	CML_FLAGS		;wenn COMLINE_ERROR,
	ANDA	#_COMLINE_FLAG		;dann
	PSHA				;  CML_FLAGS._COMLINE_FLAG retten
	JSR	COMLINE_RESET		;  Kommandoausführung abbrechen
	PULA				;  CML_FLAGS._COMLINE_FLAG restaurieren
					;
CHK_CMD_STATUS9:
	RTS				;
					;
	dcb.b	6, 0FFh			;
	SWI				;
					;
;------------------------------------------------------------------------------
